
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>huffman: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/mjjs/gompressor/huffman/huffman.go (100.0%)</option>
				
				<option value="file1">github.com/mjjs/gompressor/linkedlist/linkedlist.go (100.0%)</option>
				
				<option value="file2">github.com/mjjs/gompressor/lzw/dictionary/dictionary.go (91.4%)</option>
				
				<option value="file3">github.com/mjjs/gompressor/lzw/lzw.go (94.5%)</option>
				
				<option value="file4">github.com/mjjs/gompressor/priorityqueue/priorityqueue.go (100.0%)</option>
				
				<option value="file5">github.com/mjjs/gompressor/vector/vector.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package huffman implements the huffman coding algorithm which can be used
// for compressing data.
package huffman

import (
        "errors"
        "fmt"

        "github.com/mjjs/gompressor/lzw/dictionary"
        "github.com/mjjs/gompressor/priorityqueue"
        "github.com/mjjs/gompressor/vector"
)

type huffmanTreeNode struct {
        frequency int
        value     byte
        left      *huffmanTreeNode
        right     *huffmanTreeNode
}

// Compress takes in a vector of uncompressed bytes and outputs a vector of
// compressed bytes.
func Compress(uncompressed *vector.Vector) *vector.Vector <span class="cov8" title="1">{
        frequencies := createFrequencyTable(uncompressed)
        prefixTree := buildPrefixTree(frequencies)

        codes := dictionary.New()
        buildCodes(prefixTree, vector.New(), codes)

        compressed := vector.New()
        compressPrefixTree(prefixTree, compressed)
        compressHuffmanCodes(uncompressed, codes, compressed)

        return compressed
}</span>

// Decompress takes in a vector of huffman compressed bytes and outputs a vector
// of uncompressed bytes. Returns a non-nil error if the decompression fails.
func Decompress(compressed *vector.Vector) (*vector.Vector, error) <span class="cov8" title="1">{
        prefixTree, nextIndex := decompressPrefixTree(compressed, 0)
        decompressed := vector.New()

        var err error

        for nextIndex &lt; compressed.Size() </span><span class="cov8" title="1">{
                nextIndex, err = decodeHuffmanCode(compressed, nextIndex, prefixTree, decompressed)

                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return decompressed, nil</span>
}

func createFrequencyTable(bytes *vector.Vector) *dictionary.Dictionary <span class="cov8" title="1">{
        dict := dictionary.New()
        for i := 0; i &lt; bytes.Size(); i++ </span><span class="cov8" title="1">{
                byt := bytes.MustGet(i)

                if frequency, exists := dict.Get(byt); !exists </span><span class="cov8" title="1">{
                        dict.Set(byt, 1)
                }</span> else<span class="cov8" title="1"> {
                        dict.Set(byt, frequency.(int)+1)
                }</span>
        }

        <span class="cov8" title="1">return dict</span>
}

func buildPrefixTree(byteFrequencies *dictionary.Dictionary) *huffmanTreeNode <span class="cov8" title="1">{
        tree := new(priorityqueue.PriorityQueue)
        keys := byteFrequencies.Keys()

        for i := 0; i &lt; keys.Size(); i++ </span><span class="cov8" title="1">{
                byt := keys.MustGet(i)
                frequency, _ := byteFrequencies.Get(byt)

                tree.Enqueue(frequency.(int), &amp;huffmanTreeNode{frequency: frequency.(int), value: byt.(byte)})
        }</span>

        <span class="cov8" title="1">for tree.Size() &gt; 1 </span><span class="cov8" title="1">{
                aPrio, a := tree.Dequeue()
                bPrio, b := tree.Dequeue()

                newPrio := aPrio + bPrio

                node := &amp;huffmanTreeNode{frequency: newPrio, left: a.(*huffmanTreeNode), right: b.(*huffmanTreeNode)}

                tree.Enqueue(newPrio, node)
        }</span>

        <span class="cov8" title="1">_, root := tree.Dequeue()

        return root.(*huffmanTreeNode)</span>
}

func buildCodes(root *huffmanTreeNode, str *vector.Vector, result *dictionary.Dictionary) <span class="cov8" title="1">{
        if root == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if isLeafNode(root) </span><span class="cov8" title="1">{
                result.Set(root.value, str)
        }</span>

        <span class="cov8" title="1">buildCodes(root.left, str.AppendToCopy(byte(0)), result)
        buildCodes(root.right, str.AppendToCopy(byte(1)), result)</span>
}

func compressPrefixTree(root *huffmanTreeNode, to *vector.Vector) <span class="cov8" title="1">{
        switch isLeafNode(root) </span>{
        case true:<span class="cov8" title="1">
                // This can be optimzied to 1 bit if needed
                to.Append(byte(1))
                to.Append(root.value)</span>
        case false:<span class="cov8" title="1">
                // This can be optimzied to 1 bit if needed
                to.Append(byte(0))
                compressPrefixTree(root.left, to)
                compressPrefixTree(root.right, to)</span>
        }
}

func decompressPrefixTree(compressed *vector.Vector, index int) (*huffmanTreeNode, int) <span class="cov8" title="1">{
        byt := compressed.MustGet(index).(byte)
        switch byt </span>{
        case 0x00:<span class="cov8" title="1">
                left, nextIndex := decompressPrefixTree(compressed, index+1)
                right, nextIndex := decompressPrefixTree(compressed, nextIndex)
                return &amp;huffmanTreeNode{left: left, right: right}, nextIndex</span>

        case 0x01:<span class="cov8" title="1">
                return &amp;huffmanTreeNode{value: compressed.MustGet(index + 1).(byte)}, index + 2</span>

        default:<span class="cov8" title="1">
                return nil, index + 1</span>
        }
}

func decodeHuffmanCode(compressed *vector.Vector, index int, root *huffmanTreeNode, to *vector.Vector) (int, error) <span class="cov8" title="1">{
        if root == nil </span><span class="cov8" title="1">{
                return 0, errors.New("No prefix tree supplied")
        }</span>

        <span class="cov8" title="1">if isLeafNode(root) </span><span class="cov8" title="1">{
                to.Append(root.value)
                return index, nil
        }</span>

        <span class="cov8" title="1">next := compressed.MustGet(index).(byte)
        switch next </span>{
        case 0x00:<span class="cov8" title="1">
                return decodeHuffmanCode(compressed, index+1, root.left, to)</span>
        case 0x01:<span class="cov8" title="1">
                return decodeHuffmanCode(compressed, index+1, root.right, to)</span>
        default:<span class="cov8" title="1">
                return 0, fmt.Errorf("An unexpected symbol %x found in the compressed data", next)</span>
        }
}

func compressHuffmanCodes(uncompressed *vector.Vector, codes *dictionary.Dictionary, to *vector.Vector) <span class="cov8" title="1">{
        for i := 0; i &lt; uncompressed.Size(); i++ </span><span class="cov8" title="1">{
                value := uncompressed.MustGet(i)
                iCode, _ := codes.Get(value)
                code := iCode.(*vector.Vector)

                for j := 0; j &lt; code.Size(); j++ </span><span class="cov8" title="1">{
                        to.Append(code.MustGet(j))
                }</span>
        }
}

func isLeafNode(n *huffmanTreeNode) bool <span class="cov8" title="1">{
        return n != nil &amp;&amp; n.left == nil &amp;&amp; n.right == nil
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package linkedlist

type node struct {
        value interface{}
        next  *node
}

// LinkedList is the main structure of the linked list.
type LinkedList struct {
        head *node
        tail *node
        size int
}

// New returns a pointer to a new LinkedList and sets root as the head and tail nodes.
func New(root interface{}) *LinkedList <span class="cov8" title="1">{
        n := &amp;node{value: root}

        return &amp;LinkedList{
                head: n,
                tail: n,
                size: 1,
        }
}</span>

// Append appends the given value to the end of the list.
func (ll *LinkedList) Append(value interface{}) <span class="cov8" title="1">{
        newNode := &amp;node{value: value}

        if ll.size == 0 </span><span class="cov8" title="1">{
                ll.head = newNode
                ll.tail = newNode
        }</span> else<span class="cov8" title="1"> {
                ll.tail.next = newNode
                ll.tail = newNode
        }</span>

        <span class="cov8" title="1">ll.size++</span>
}

// Remove removes value from the linked list.
func (ll *LinkedList) Remove(value interface{}) <span class="cov8" title="1">{
        if ll.head.value == value </span><span class="cov8" title="1">{
                ll.head = ll.head.next
        }</span>

        <span class="cov8" title="1">removed := ll.remove(ll.head, value)
        if removed </span><span class="cov8" title="1">{
                ll.size--
        }</span>
}

// Find finds the given value from the linked list and returns it if found.
// A boolean value is returned indicating whether or not the value actually
// exists in the linked list.
func (ll *LinkedList) Find(value interface{}) (interface{}, bool) <span class="cov8" title="1">{
        result := find(ll.head, value)
        if result == nil </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">return result.value, true</span>
}

// Head returns the head of the linked list.
func (ll *LinkedList) Head() interface{} <span class="cov8" title="1">{
        if ll.head == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return ll.head.value</span>
}

// Tail returns the tail of the linked list.
func (ll *LinkedList) Tail() interface{} <span class="cov8" title="1">{
        if ll.tail == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return ll.tail.value</span>
}

// Size returns the number of elements in the linked list.
func (ll *LinkedList) Size() int <span class="cov8" title="1">{
        return ll.size
}</span>

// ForEach executes f for each element in the list.
func (ll *LinkedList) ForEach(f func(val interface{})) <span class="cov8" title="1">{
        execFunc(ll.head, f)
}</span>

func (ll *LinkedList) remove(n *node, val interface{}) bool <span class="cov8" title="1">{
        if n == nil || n.next == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if n.next.value == val </span><span class="cov8" title="1">{
                if n.next == ll.tail </span><span class="cov8" title="1">{
                        ll.tail = n
                }</span>

                <span class="cov8" title="1">n.next = n.next.next
                return true</span>
        }

        <span class="cov8" title="1">return ll.remove(n.next, val)</span>
}

func execFunc(n *node, f func(val interface{})) <span class="cov8" title="1">{
        if n == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">f(n.value)

        execFunc(n.next, f)</span>
}

func find(n *node, val interface{}) *node <span class="cov8" title="1">{
        if n == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if n.value == val </span><span class="cov8" title="1">{
                return n
        }</span>

        <span class="cov8" title="1">return find(n.next, val)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package dictionary

import (
        "github.com/mjjs/gompressor/linkedlist"
        "github.com/mjjs/gompressor/vector"
)

const defaultSize uint = 32

type dictionaryNode struct {
        key   interface{}
        value interface{}
}

// Dictionary is a hash table data structure used by the LZW algorithm.
type Dictionary struct {
        buckets []*linkedlist.LinkedList
        size    int
}

// New returns a pointer to a new Dictionary with an initial size.
func New() *Dictionary <span class="cov8" title="1">{
        return NewWithSize(defaultSize)
}</span>

// NewWithSize returns a pointer to a new Dictionary with the given size. If
// zero is passed in as size, the default size is used.
func NewWithSize(size uint) *Dictionary <span class="cov8" title="1">{
        buckets := make([]*linkedlist.LinkedList, size)
        for i := range buckets </span><span class="cov8" title="1">{
                buckets[i] = new(linkedlist.LinkedList)
        }</span>

        <span class="cov8" title="1">return &amp;Dictionary{buckets: buckets}</span>
}

// Set maps key to value in the dictionary. If key is present in the map, the
// value is updated.
func (d *Dictionary) Set(key interface{}, value interface{}) <span class="cov8" title="1">{
        bucket := d.getBucket(key)

        updated := false

        bucket.ForEach(func(iNode interface{}) </span><span class="cov8" title="1">{
                if updated </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">node := iNode.(*dictionaryNode)
                if node.key == key </span><span class="cov8" title="1">{
                        node.value = value
                        updated = true
                }</span>
        })

        <span class="cov8" title="1">if updated </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">bucket.Append(&amp;dictionaryNode{key: key, value: value})
        d.size++

        if float32(d.size/len(d.buckets)) &gt; 0.75 </span><span class="cov8" title="1">{
                d.grow()
        }</span>
}

// Get returns the value associated with key. An additional boolean value is
// returned to indicate whether or not the key exists in the map.
func (d *Dictionary) Get(key interface{}) (interface{}, bool) <span class="cov8" title="1">{
        bucket := d.getBucket(key)

        var value interface{} = nil
        found := false

        bucket.ForEach(func(iNode interface{}) </span><span class="cov8" title="1">{
                if found </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">node := iNode.(*dictionaryNode)
                if node.key == key </span><span class="cov8" title="1">{
                        value = node.value
                        found = true
                }</span>
        })

        <span class="cov8" title="1">return value, found</span>
}

// Remove removes the the given key-value pair from the dictionary.
func (d *Dictionary) Remove(key interface{}) <span class="cov8" title="1">{
        bucket := d.getBucket(key)

        removed := false

        bucket.ForEach(func(iNode interface{}) </span><span class="cov8" title="1">{
                if removed </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">node := iNode.(*dictionaryNode)
                if node.key == key </span><span class="cov8" title="1">{
                        removed = true
                        bucket.Remove(iNode)
                }</span>
        })

        <span class="cov8" title="1">d.size--</span>
}

// Size returns the amount of unique values present in the dictionary.
func (d *Dictionary) Size() int <span class="cov8" title="1">{
        return d.size
}</span>

// Keys returns a vector containing all the keys in the dictionary.
func (d *Dictionary) Keys() *vector.Vector <span class="cov8" title="1">{
        keys := vector.New()

        for _, bucket := range d.buckets </span><span class="cov8" title="1">{
                bucket.ForEach(func(node interface{}) </span><span class="cov8" title="1">{
                        keys.Append(node.(*dictionaryNode).key)
                }</span>)
        }

        <span class="cov8" title="1">return keys</span>
}

func (d *Dictionary) getBucket(key interface{}) *linkedlist.LinkedList <span class="cov8" title="1">{
        hash := hash(key)
        n := int64(len(d.buckets))

        return d.buckets[((hash%n)+n)%n]
}</span>

func (d *Dictionary) grow() <span class="cov8" title="1">{
        newBuckets := make([]*linkedlist.LinkedList, d.size*2)
        for i := range newBuckets </span><span class="cov8" title="1">{
                newBuckets[i] = new(linkedlist.LinkedList)
        }</span>

        <span class="cov8" title="1">n := int64(len(newBuckets))

        for _, bucket := range d.buckets </span><span class="cov8" title="1">{
                bucket.ForEach(func(node interface{}) </span><span class="cov8" title="1">{
                        hash := hash((node.(*dictionaryNode).key))
                        newBucket := newBuckets[((hash%n)+n)%n]
                        newBucket.Append(node)
                }</span>)
        }

        <span class="cov8" title="1">d.buckets = newBuckets</span>
}

func hash(key interface{}) int64 <span class="cov8" title="1">{
        switch v := key.(type) </span>{
        case string:<span class="cov8" title="1">
                const (
                        prime  int64 = 31
                        modulo int64 = 1e9 + 9
                )

                var (
                        hash       int64 = 0
                        primePower int64 = 1
                )

                for _, c := range v </span><span class="cov8" title="1">{
                        hash = (hash + (int64(c-'a')+1)*primePower) % modulo
                        primePower = (primePower * prime) % modulo
                }</span>

                <span class="cov8" title="1">return hash</span>
        case uint16:<span class="cov0" title="0">
                return int64(v)</span>
        case byte:<span class="cov0" title="0">
                return int64(v)</span>
        default:<span class="cov0" title="0">
                panic("Unsupported key type")</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package lzw

import (
        "errors"
        "fmt"

        "github.com/mjjs/gompressor/lzw/dictionary"
        "github.com/mjjs/gompressor/vector"
)

const (
        initialDictSize uint16 = 256
        maxDictSize     uint16 = 65535
)

// ErrBadCompressedCode represents an error that occurs when the LZW decompression
// algorithm finds a code that is not valid for the assumed compression algorithm.
var ErrBadCompressedCode = errors.New("bad compression code")

// Compress takes a slice of uncompressed bytes as input and returns a slice of
// LZW codes that represent the compressed data.
func Compress(uncompressed *vector.Vector) (*vector.Vector, error) <span class="cov8" title="1">{
        createInitialDictionary := func() *dictionary.Dictionary </span><span class="cov8" title="1">{
                dict := dictionary.NewWithSize(uint(initialDictSize))

                for i := uint16(0); i &lt; initialDictSize; i++ </span><span class="cov8" title="1">{
                        dict.Set(string([]byte{byte(i)}), i)
                }</span>

                <span class="cov8" title="1">return dict</span>
        }

        <span class="cov8" title="1">dict := createInitialDictionary()

        compressed := vector.New()
        word := vector.New()

        for i := 0; i &lt; uncompressed.Size(); i++ </span><span class="cov8" title="1">{
                if dict.Size() == int(maxDictSize) </span><span class="cov0" title="0">{
                        dict = createInitialDictionary()
                }</span>

                <span class="cov8" title="1">byt := uncompressed.MustGet(i)
                newWord := word.AppendToCopy(byt)

                if _, ok := dict.Get(newWord.String()); ok </span><span class="cov8" title="1">{
                        word = vector.New(uint(newWord.Size()))

                        for j := 0; j &lt; newWord.Size(); j++ </span><span class="cov8" title="1">{
                                word.MustSet(j, newWord.MustGet(j))
                        }</span>
                } else<span class="cov8" title="1"> {
                        code, _ := dict.Get(word.String())
                        compressed.Append(code.(uint16))

                        dict.Set(newWord.String(), uint16(dict.Size()))
                        word = vector.New().AppendToCopy(byt)
                }</span>
        }

        <span class="cov8" title="1">if word.Size() &gt; 0 </span><span class="cov8" title="1">{
                code, _ := dict.Get(word.String())
                compressed.Append(code.(uint16))
        }</span>

        <span class="cov8" title="1">return compressed, nil</span>
}

// Decompress takes in a slice of LZW codes representing some compressed data
// and outputs the decompressed data as a slice of bytes.
// An error is returned if the decompression algorithm finds a bad LZW code.
func Decompress(compressed *vector.Vector) (*vector.Vector, error) <span class="cov8" title="1">{
        createInitialDictionary := func() *dictionary.Dictionary </span><span class="cov8" title="1">{
                dict := dictionary.NewWithSize(uint(initialDictSize))

                for i := uint16(0); i &lt; initialDictSize; i++ </span><span class="cov8" title="1">{
                        bv := vector.New(1)
                        bv.MustSet(0, byte(i))
                        dict.Set(i, bv)
                }</span>

                <span class="cov8" title="1">return dict</span>
        }

        <span class="cov8" title="1">dict := createInitialDictionary()

        result := vector.New()
        word := vector.New()

        for i := 0; i &lt; compressed.Size(); i++ </span><span class="cov8" title="1">{
                if dict.Size() == int(maxDictSize) </span><span class="cov0" title="0">{
                        dict = createInitialDictionary()
                }</span>

                <span class="cov8" title="1">code := compressed.MustGet(i)

                entry := vector.New()

                if c, ok := dict.Get(code); ok </span><span class="cov8" title="1">{
                        byteVector := c.(*vector.Vector)

                        entry = vector.New(uint(byteVector.Size()))
                        for i := 0; i &lt; byteVector.Size(); i++ </span><span class="cov8" title="1">{
                                entry.MustSet(i, byteVector.MustGet(i))
                        }</span>
                } else<span class="cov8" title="1"> if int(code.(uint16)) == dict.Size() &amp;&amp; word.Size() &gt; 0 </span><span class="cov8" title="1">{
                        entry = word.AppendToCopy(word.MustGet(0))
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("%w: %d", ErrBadCompressedCode, code)
                }</span>

                <span class="cov8" title="1">for i := 0; i &lt; entry.Size(); i++ </span><span class="cov8" title="1">{
                        result.Append(entry.MustGet(i))
                }</span>

                <span class="cov8" title="1">if word.Size() &gt; 0 </span><span class="cov8" title="1">{
                        word = word.AppendToCopy(entry.MustGet(0))
                        dict.Set(uint16(dict.Size()), word)
                }</span>

                <span class="cov8" title="1">word = entry</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package priorityqueue implements implements a priority queue which considers
// lower values to be of higher priority.
package priorityqueue

import (
        "github.com/mjjs/gompressor/vector"
)

type node struct {
        priority int
        value    interface{}
}

// PriorityQueue is the type which implements the priority queue.
type PriorityQueue struct {
        nodes vector.Vector
}

// Enqueue adds value to the queue with the given priority. Elements are re-ordered
// if needed so that the heap property is satisfied.
func (pq *PriorityQueue) Enqueue(priority int, value interface{}) <span class="cov8" title="1">{
        pq.nodes.Append(&amp;node{priority: priority, value: value})
        pq.siftUp(pq.nodes.Size() - 1)
}</span>

// Dequeue removes the element with the highest priority and returns it to the caller.
// The rest of the tree is re-ordered to satisfy the heap property.
func (pq *PriorityQueue) Dequeue() (int, interface{}) <span class="cov8" title="1">{
        if pq.nodes.Size() == 0 </span><span class="cov8" title="1">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">head := pq.nodes.MustGet(0).(*node)

        pq.nodes.MustSet(0, pq.nodes.MustGet(pq.nodes.Size()-1))
        pq.nodes.Pop()

        if pq.nodes.Size() &gt; 1 </span><span class="cov8" title="1">{
                pq.siftDown(0)
        }</span>

        <span class="cov8" title="1">return head.priority, head.value</span>
}

// Peek returns the highest priority element to the caller without removing it
// from the queue.
func (pq *PriorityQueue) Peek() (int, interface{}) <span class="cov8" title="1">{
        if pq.nodes.Size() == 0 </span><span class="cov8" title="1">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">node := pq.nodes.MustGet(0).(*node)

        return node.priority, node.value</span>
}

// Size returns the amount of elements in the queue.
func (pq *PriorityQueue) Size() int <span class="cov8" title="1">{
        return pq.nodes.Size()
}</span>

func (pq *PriorityQueue) siftUp(i int) <span class="cov8" title="1">{
        parent := (i - 1) / 2

        currentNode := pq.nodes.MustGet(i).(*node)
        parentNode := pq.nodes.MustGet(parent).(*node)

        if currentNode.priority &lt; parentNode.priority </span><span class="cov8" title="1">{
                pq.swap(i, parent)
                pq.siftUp(parent)
        }</span>
}

func (pq *PriorityQueue) siftDown(i int) <span class="cov8" title="1">{
        if i &gt;= pq.nodes.Size()/2 &amp;&amp; i &lt;= pq.nodes.Size() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">smallest := i
        left := i*2 + 1
        right := i*2 + 2

        if left &lt; pq.nodes.Size() &amp;&amp; pq.nodes.MustGet(left).(*node).priority &lt; pq.nodes.MustGet(smallest).(*node).priority </span><span class="cov8" title="1">{
                smallest = left
        }</span>

        <span class="cov8" title="1">if right &lt; pq.nodes.Size() &amp;&amp; pq.nodes.MustGet(right).(*node).priority &lt; pq.nodes.MustGet(smallest).(*node).priority </span><span class="cov8" title="1">{
                smallest = right
        }</span>

        <span class="cov8" title="1">if smallest != i </span><span class="cov8" title="1">{
                pq.swap(i, smallest)
                pq.siftDown(smallest)
        }</span>
}

func (pq *PriorityQueue) swap(i, j int) <span class="cov8" title="1">{
        temp := pq.nodes.MustGet(i)
        pq.nodes.MustSet(i, pq.nodes.MustGet(j))
        pq.nodes.MustSet(j, temp)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package vector

import (
        "errors"
        "fmt"
)

const defaultCapacity int = 10

// ErrIndexOutOfRange is an error that is returned when accessing the vector
// using an index that is negative or greater than the capacity of the given
// vector.
var ErrIndexOutOfRange = errors.New("index out of range")

// Vector is a dynamic array that holds bytes.
type Vector struct {
        size     int
        capacity int
        elements []interface{}
}

// New returns a pointer to a Vector. The size specifies the length of the
// initial vector. The vector will hold size amount of zero valued bytes.
//
// An additional uint can be passed to New, which indicates how many values
// the underlying array can hold before resizing. If capacity is smaller than length,
// capacity will be set to equal length.
func New(size ...uint) *Vector <span class="cov8" title="1">{
        switch len(size) </span>{
        case 1:<span class="cov8" title="1">
                return &amp;Vector{
                        size:     int(size[0]),
                        capacity: int(size[0]),
                        elements: make([]interface{}, size[0]),
                }</span>

        case 2:<span class="cov8" title="1">
                var sz = int(size[0])
                var capacity = int(size[1])

                if capacity &lt; sz </span><span class="cov8" title="1">{
                        capacity = sz
                }</span>

                <span class="cov8" title="1">return &amp;Vector{
                        capacity: capacity,
                        size:     sz,
                        elements: make([]interface{}, capacity),
                }</span>

        default:<span class="cov8" title="1">
                return &amp;Vector{
                        elements: make([]interface{}, 0),
                }</span>
        }
}

// Append adds the values to the end of the vector, growing it if necessary.
func (v *Vector) Append(values ...interface{}) <span class="cov8" title="1">{
        for _, value := range values </span><span class="cov8" title="1">{
                if v.size == v.capacity </span><span class="cov8" title="1">{
                        v.grow()
                }</span>

                <span class="cov8" title="1">v.elements[v.size] = value
                v.size++</span>
        }
}

// Pop removes the last element from the vector.
func (v *Vector) Pop() interface{} <span class="cov8" title="1">{
        if v.size == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">tail := v.elements[v.size-1]
        v.size--
        return tail</span>
}

// AppendToCopy creates a copy of v and appends the values to the end of the
// copy and returns the copy. The copy is grown if necessary.
func (v *Vector) AppendToCopy(values ...interface{}) *Vector <span class="cov8" title="1">{
        newVector := New(uint(v.size), uint(v.capacity))

        for i := 0; i &lt; v.size; i++ </span><span class="cov8" title="1">{
                newVector.Set(i, v.MustGet(i))
        }</span>

        <span class="cov8" title="1">newVector.Append(values...)

        return newVector</span>
}

// Get returns the value at the given index. Returns an error if the index
// is out or range.
func (v *Vector) Get(index int) (interface{}, error) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= v.size </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %d", ErrIndexOutOfRange, index)
        }</span>

        <span class="cov8" title="1">return v.elements[index], nil</span>
}

// MustGet returns the value at the given index without performing any bounds checking.
func (v *Vector) MustGet(index int) interface{} <span class="cov8" title="1">{
        return v.elements[index]
}</span>

// Set sets value into the given index. Returns an error if the index is out of range.
func (v *Vector) Set(index int, value interface{}) error <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= v.size </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: %d", ErrIndexOutOfRange, index)
        }</span>

        <span class="cov8" title="1">v.elements[index] = value

        return nil</span>
}

// MustSet sets value into the given index without performing any bounds checking.
func (v *Vector) MustSet(index int, value interface{}) <span class="cov8" title="1">{
        v.elements[index] = value
}</span>

// Size returns the number of elements in the vector.
func (v *Vector) Size() int <span class="cov8" title="1">{
        return v.size
}</span>

// Capacity returns the number of elements the vector can hold before resizing.
func (v *Vector) Capacity() int <span class="cov8" title="1">{
        return v.capacity
}</span>

// String returns the string representation of the bytes in the vector.
func (v *Vector) String() string <span class="cov8" title="1">{
        s := ""

        for i := 0; i &lt; v.size; i++ </span><span class="cov8" title="1">{
                switch val := v.elements[i].(type) </span>{
                case byte:<span class="cov8" title="1">
                        s += string([]byte{val})</span>
                default:<span class="cov8" title="1">
                        panic(fmt.Sprintf("String not implemented for %T", v.elements[i]))</span>
                }
        }

        <span class="cov8" title="1">return s</span>
}

func (v *Vector) grow() <span class="cov8" title="1">{
        newCapacity := v.capacity * 2

        if v.capacity == 0 </span><span class="cov8" title="1">{
                newCapacity = 1
        }</span>

        <span class="cov8" title="1">newElements := make([]interface{}, newCapacity)

        for i := 0; i &lt; v.size; i++ </span><span class="cov8" title="1">{
                newElements[i] = v.elements[i]
        }</span>

        <span class="cov8" title="1">v.capacity = newCapacity
        v.elements = newElements</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
